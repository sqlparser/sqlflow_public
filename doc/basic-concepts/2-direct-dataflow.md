[toc]
## Exploring Direct Data Flow

In our introduction, we learned that a **direct data flow** is when data moves from a source to a target. This is the most common and straightforward type of data lineage. This article explores several common SQL patterns that create these direct data flows.

### 1. Direct Flow in `SELECT` Statements

The simplest example of a direct data flow is a basic `SELECT` statement. When you select a column, its data is directly copied to the result of your query.

```sql
SELECT a.empName AS "eName"
FROM scott.emp a
WHERE sal > 1000
```

In this query, the data from the `empName` column in the `scott.emp` table flows directly to the output column, which is renamed to `"eName"`.

The lineage is clear and simple:

`scott.emp.empName -> direct -> Result."eName"`

Effect type:
- v1: effectType: select (produced by a SELECT projection)
- v2: effectType: EXACT_COPY (alias passthrough; no semantic change)

This is visualized with a solid arrow from the source column to the target column.

![Direct data flow in a SELECT statement](https://images.gitee.com/uploads/images/2021/0702/165128_bef55fd4_8136809.png)

### 2. Direct Flow Through Functions

Functions are a common way to transform data. Even when a function modifies a value (like rounding a number or changing text to uppercase), SQLFlow still considers this a direct data flow because the output is directly derived from the input.

```sql
SELECT ROUND(salary) AS sal 
FROM scott.emp
```

The lineage here is a two-step process:
1.  Data flows from the `salary` column *into* the `ROUND()` function.
2.  The result from the `ROUND()` function flows *out to* the final `sal` column.

This detailed view shows the function as an intermediate step in the transformation:

`scott.emp.salary -> direct -> ROUND() -> direct -> sal`

Effect type:
- v1: function edge: effectType: function; function result to select list: effectType: select
- v2: effectType: WEAK_COPY (ROUND changes value; transforms.code: "ROUND(salary)")

![Data flow through a function](https://images.gitee.com/uploads/images/2021/0702/172358_bc2c88ad_8136809.png)

#### Simplified View

For a higher-level view, you might want to hide the function and just see the direct relationship from the original source to the final target. SQLFlow allows you to toggle this view, simplifying the diagram to show:

`scott.emp.salary -> direct -> sal`

![Simplified data flow, hiding the function](https://images.gitee.com/uploads/images/2021/0702/172626_96c936a1_8136809.png)

### 3. Direct Flow Between Tables

Direct data flows are not limited to queries. They are fundamental to how data moves between tables using statements like `INSERT`, `UPDATE`, `MERGE`, or `CREATE TABLE AS SELECT`.

#### `INSERT ... SELECT` Example

An `INSERT ... SELECT` statement is a classic example of data flowing directly from one table to another.

```sql
INSERT INTO employees_archive (emp_id, emp_name)
SELECT emp_no, emp_name
FROM employees
WHERE hire_date < '2020-01-01';
```

Here, SQLFlow will create two direct data flows:
*   `employees.emp_no -> direct -> employees_archive.emp_id`
*   `employees.emp_name -> direct -> employees_archive.emp_name`

Effect type:
- v1: effectType: insert (produced by an INSERT ... SELECT)
- v2: effectType: EXACT_COPY for both edges (passthrough mapping); grouped by a shared statementKey (these edges come from the same statement)

This clearly shows that data from the `employees` table is being used to populate the `employees_archive` table.

### References

1. XML code used in this article is generated by [DataFlowAnalyzer](https://github.com/sqlparser/gsp_demo_java/tree/master/src/main/java/demos/dlineage) tools.
2. Diagrams used in this article are generated by the [Gudu SQLFlow Cloud version](https://sqlflow.gudusoft.com/).

## A Look Ahead: Direct Data Flow in the v2 Model

The next generation of SQLFlow's lineage model (v2, under development) keeps the same intuition for direct data flow, but records it with more precision and better traceability.

### How v1 Maps to v2 (Direct Flow)

-  **v1 `fdd` (direct data flow)**: becomes **`data_flow`** in v2. Same meaning, clearer name.
-  **Functions shown as nodes (optional in v1 view)**: in v2, the function logic is captured on the edge via **`transforms`** (e.g., code="ROUND(salary)").
-  **Multiple columns in one statement**: v2 uses many 1→1 edges (atomic relationships), grouped by a **`statementKey`** so you can still treat them as one operation.
-  **Traceability**: v2 adds **`observations`** to each relationship with file/line anchors, plus stable object IDs using **`qualifiedName`**.
-  **Effect type**: v2 uses `effectType` to convey copy/aggregation strength (e.g., EXACT_COPY, WEAK_COPY, AGGREGATION, AMBIGUOUS).

### Examples (v1 → v2)

-  **Function in SELECT**
   - v1 view: `scott.emp.salary -> direct -> ROUND() -> direct -> sal` (effectType: function → select)
   - v2 edge: `data_flow` from `salary` to `sal`
     - transforms: `[ { type: "function", code: "ROUND(salary)" } ]`
     - effectType: `WEAK_COPY` (rounding changes value; not reversible)

-  **INSERT ... SELECT**
   - v1 view: two direct flows (effectType: insert)
     - `employees.emp_no -> direct -> employees_archive.emp_id`
     - `employees.emp_name -> direct -> employees_archive.emp_name`
   - v2 edges: the same two 1→1 `data_flow` edges
     - effectType: `EXACT_COPY` (alias/passthrough)
     - grouped by `statementKey` to indicate they came from the same SQL statement
     - each edge can carry `observations` that point to the exact lines in your script

What you gain with v2:
-  **Clarity**: direct flows are still simple, but transformations are explicit on the edge.
-  **Evidence**: each flow can be traced back to the precise code that produced it.
-  **Scalability**: atomic edges + grouping make complex statements easier to understand and manage.